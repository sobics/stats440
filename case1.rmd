---
  title: "casestudy1_2"
author: "Sonia Xu"
date: "September 9, 2017"
output: html_document
---
  
#read in the data
```{r include = F}
library(dplyr)
library(lme4)
library(ggplot2)

###plot multiple ggplots in one place  obtained from http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

####

dat <- read.table("case1.txt", header = T, stringsAsFactors = F, na.strings = ".", colClasses=c("character","character","numeric","numeric","numeric","numeric","numeric","numeric"))
dat <-  dat %>% filter(complete.cases(blot)) %>% mutate(wblot = blot/body, wwet = wet/body)
```

To continue our exploration of modelling the data, we decided to split the cleaned dataset into test and training data. By understanding how well the models predict the blotted uterus weight, we can see if there is improvement from the simple linear model by adding random effects.
#Split the data into training and test
```{r}
set.seed(3)
samp <- sample(dim(dat)[1], dim(dat)[1]/10)
test <- dat[samp,]
train <- dat[-samp,]
```

#proposed model from case study 1
```{r}
fm1 <- lmer(wblot ~ 1 + (proto|lab) + body + poly(dose1,2) + poly(dose2,2), train)
summary(fm1)

p_fm1 <- predict(fm1, test)

ggplot(data = test, aes(p_fm1, wblot)) + geom_point(aes(colour = lab)) + geom_smooth() + geom_line(aes(colour=lab), linetype=5)

```

```{r}
fm2 <- lmer(wblot ~ 1 + (proto|lab) + body + poly(dose1,2) + poly(dose2,2), dat)
summary(fm2)
p_fm2 <- predict(fm2, dat)
ggplot(data = dat, aes(p_fm2, wblot)) + geom_smooth() + geom_point(aes(colour = lab), alpha = 0.3) 

```
Overall, the predictive power of our intuitive model seems to work pretty well. 

However, for each dose, the response trend varies per lab.
```{r}
mean_dat1 <- dat %>% group_by(lab, dose1) %>% summarise(wblot = mean(wblot))
ggplot(data = mean_dat1, aes(x = dose1, y = wblot, color = lab)) + geom_line()
mean_dat2 <- dat %>% group_by(lab, dose2) %>% summarise(wblot = mean(wblot))
ggplot(data = mean_dat2, aes(x = dose2, y = wblot, color = lab)) + geom_line()

```

#minimum model proposed in class monday
Due to the high variance in the effect of dose between labs, the minimum model was altered to include dose1 and dose2 for each lab.
```{r}
#dose response curve
minmod <- lmer(wblot ~ (1 + proto + dose1 + dose2| lab), dat) #minimum model
summary(minmod)
plot(minmod)
p_minmod <- predict(minmod, test)
ggplot(data = dat, aes(p_minmod, wblot)) + geom_smooth() + geom_point(aes(colour = lab), alpha = 0.3) #+ geom_line(aes(colour=lab), linetype=5)

```

#adding characters from proposed model to monday model
```{r}
medmod <- lmer(wblot ~ (1+ proto + poly(dose1,2) + poly(dose2,2) |lab)+poly(dose1,2)+poly(dose2,2)+poly(body,2)+(proto*lab), dat) #med model
summary(minmod)
plot(medmod)
p_medmod <- predict(medmod, test)
ggplot(data = test, aes(p_medmod, wblot)) + geom_point(aes(colour = lab)) + geom_smooth() + geom_line(aes(colour=lab), linetype=5)

par(mfrow = c(2,2))
test_p <- ggplot(data = test, aes(x = wblot)) + geom_histogram() + lims(x = c(0,4)) + theme_bw()
min_p <- ggplot(test,aes(p_minmod)) + geom_histogram() + lims(x = c(0,4)) + theme_bw()
med_p <- ggplot(test,aes(p_medmod)) + geom_histogram() + lims(x = c(0,4)) + theme_bw()
multiplot(test_p, min_p, med_p, cols = 2)
```
After exploring and comparing multiple models, our final model is $y_{wblot} = \mu_i + \beta_{proto,i}proto_{ij} * \beta_{lab}lab_{ij}+ \beta_{dose1}*dose1_{ij} + \beta_{dose2}*dose2_{ij} + \beta_{body}*body_{ij} + \epsilon_{ij}$$ where $\epsilon_{ij} \sim N(0,\nu^2)$ and $\mu_i \sim N(\mu, \sigma^2)$$.

We noticed that adding dose1 and dose2 as both fixed and random effects better fit the data. The fixed effect captures the population effects of dose1 and dose2 across all labs and random effect captures the variation in the effects of dose1 and dose2 between labs. Similarly, we also assumed that there were variations between protocol and lab, so we added an interaction term between protocol and lab as a fixed effect and as a random effect. The fixed effect captures the population differences between each protocol and lab, and the random effect captures the lab-specific variation between protocol and lab. We decided to transform body weight, dose1, and dose2 to a polynomial with a degree of 2 because the scatterplot indicated a nonlinear trend between body weight and the response, the weighted blot. 

Conclusion
From this final model, we can conclude:
1. The body weight
2. Concave up 
3. Concave down
